% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/score_predictions.R
\name{score_predictions}
\alias{score_predictions}
\title{Compute time-dependent predictive accuracy metrics (AUC and Brier Score)}
\usage{
score_predictions(risk, pred_times, time, event, metrics = c("auc", "brier"))
}
\arguments{
\item{risk}{a numeric matrix of dimension \eqn{n \times T}{n x T} giving the predicted risk
(i.e., event probability) for each subject (row) at each evaluation time (column).
For survival predictions, this should be \eqn{1 - S(t)}. For competing risks, this should
be the cause-specific cumulative incidence function (CIF).}

\item{pred_times}{a numeric vector of length \eqn{T} giving the evaluation time points
corresponding to the columns of \code{risk}.}

\item{time}{a numeric vector of length \eqn{n} giving the observed event or censoring time
for each subject.}

\item{event}{a numeric or integer vector of length \eqn{n} giving the event indicator for
each subject (1 = event occurred, 0 = censored). For competing risks, use the cause-specific
event indicator (1 = event of interest, 0 = censored or competing event; see Details).}

\item{metrics}{character vector specifying which metrics to compute. Options are \code{"auc"},
\code{"brier"}, or both (default is \code{c("auc", "brier")}).}
}
\value{
An object of class \code{"score_predictions"}, which is a list containing:
\describe{
  \item{scores}{A data.frame with columns \code{time} and the requested metrics
    (\code{AUC} and/or \code{Brier}).}
  \item{metrics}{Character vector of metrics computed.}
  \item{pred_times}{The evaluation time points.}
  \item{n_subjects}{Number of subjects.}
  \item{n_events}{Total number of events observed.}
  \item{n_censored}{Total number of censored observations.}
  \item{event_rate}{Proportion of subjects with events.}
  \item{n_cases}{Number of cases (events before each \code{pred_times}) used for AUC.}
  \item{n_controls}{Number of controls (event-free at each \code{pred_times}) used for AUC.}
}
}
\description{
Computes time-dependent AUC and Brier score from predicted
risks and observed outcomes.

The function handles censoring through the IPCW (Inverse Probability of Censoring Weighted)
method, which reweights contributions by the inverse of the Kaplan-Meier
estimate of the censoring distribution.
}
\details{
\strong{Brier Score (IPCW):}

The time-dependent Brier score at evaluation time \eqn{t} is defined as:
\deqn{BS(t) = \frac{1}{n}\sum_{i=1}^{n}\left[\frac{\hat{\pi}_i(t)^2 \cdot I(T_i > t)}{\hat{G}(t)} +
\frac{(1 - \hat{\pi}_i(t))^2 \cdot I(T_i \le t) \cdot \delta_i}{\hat{G}(T_i)}\right]}
where \eqn{\hat{\pi}_i(t)} is the predicted risk for subject \eqn{i} at time \eqn{t},
\eqn{T_i} is the observed time, \eqn{\delta_i} is the event indicator, and \eqn{\hat{G}(\cdot)}
is the Kaplan-Meier estimate of the censoring survival function.

\strong{AUC (IPCW):}

The time-dependent AUC at evaluation time \eqn{t} measures the concordance
between predicted risks and observed outcomes over all case-control pairs:
\deqn{AUC(t) = \frac{\sum_{i}\sum_{j} I(T_i \le t)\delta_i I(T_j > t)
I(\hat{\pi}_i(t) > \hat{\pi}_j(t)) w_{ij}(t)}{\sum_{i}\sum_{j} I(T_i \le t)
\delta_i I(T_j > t) w_{ij}(t)}}
where the IPCW weight is \eqn{w_{ij}(t) = 1 / (\hat{G}(T_i) \cdot \hat{G}(t))}.
Ties in predicted risk contribute 0.5.

\strong{Competing Risks:}

For competing risks, pass the cause-specific CIF as the \code{risk} matrix, and set
the \code{event} indicator to the binary indicator for the cause of interest
(1 = cause of interest occurred, 0 = censored or competing event). Each cause is
scored separately with its own call to \code{score_predictions()}.
}
\examples{
\donttest{
if(requireNamespace("INLA")){

# simulate longitudinal + survival data
set.seed(1)
n <- 500
sex <- rbinom(n, 1, 0.5)
b <- MASS::mvrnorm(n, mu = c(0, 0),
                   Sigma = matrix(c(4, 1.2, 1.2, 0.6), 2, 2))
long_data <- do.call(rbind, lapply(1:n, function(i) {
  times <- seq(0, 10, by = 0.5)
  Y <- 5 - 0.3 * times + 0.8 * sex[i] + b[i,1] + b[i,2] * times +
       rnorm(length(times), 0, 0.5)
  data.frame(id = i, time = times, Y = Y, sex = sex[i])
}))
surv_data <- do.call(rbind, lapply(1:n, function(i) {
  tg <- seq(0, 15, length.out = 500)
  Yt <- 5 - 0.3*tg + 0.8*sex[i] + b[i,1] + b[i,2]*tg
  h <- exp(-4 + 0.4 * Yt)
  H <- cumsum(c(0, (h[-1]+h[-length(h)])/2 * diff(tg)))
  et <- tg[which(H >= rexp(1))[1]]
  st <- min(ifelse(is.na(et), 10, et), 10)
  data.frame(id = i, survtime = st, event = as.integer(st < 10), sex = sex[i])
}))
long_data <- merge(long_data, surv_data[, c("id","survtime")], by="id")
long_data <- long_data[long_data$time <= long_data$survtime, ]
long_data$survtime <- NULL

# train/test split
train_ids <- 1:480
test_ids <- 481:500
train_long <- long_data[long_data$id \%in\% train_ids, ]
train_surv <- surv_data[surv_data$id \%in\% train_ids, ]
test_long  <- long_data[long_data$id \%in\% test_ids, ]
test_surv  <- surv_data[surv_data$id \%in\% test_ids, ]

# fit joint model on training data
fit <- joint(
  formSurv = INLA::inla.surv(survtime, event) ~ sex,
  dataSurv = train_surv,
  formLong = list(Y ~ time + sex + (1 + time | id)),
  dataLong = train_long,
  id = "id", timeVar = "time", assoc = "CV"
)

# predict for test subjects from a landmark
landmark <- 2
horizon <- 9
eval_times <- seq(4, 8)
valid_ids <- test_surv$id[test_surv$survtime >= landmark]
newdata <- test_long[test_long$id \%in\% valid_ids & test_long$time <= landmark, ]
obs_per_id <- table(newdata$id)
valid_ids <- as.integer(names(obs_per_id[obs_per_id >= 2]))
newdata <- newdata[newdata$id \%in\% valid_ids, ]
test_surv_valid <- test_surv[test_surv$id \%in\% valid_ids, ]

# fine grid that includes the integer evaluation times
fine_grid <- sort(unique(c(seq(landmark, horizon, length.out = 50), eval_times)))
pred <- predict(fit, newData = newdata, horizon = horizon,
                Csurv = landmark, survival = TRUE,
                timePoints = fine_grid)

# reshape predictions into a risk matrix
predS <- pred$PredS
ids <- unique(predS$id)
all_times <- sort(unique(predS$time))
surv_mat <- matrix(predS$Surv_quant0.5, nrow = length(ids),
                   ncol = length(all_times), byrow = TRUE)
risk_mat <- 1 - surv_mat

# select integer evaluation times for scoring
keep <- match(eval_times, all_times)
risk_mat <- risk_mat[, keep]
pred_times <- eval_times

# compute scores
sc <- score_predictions(
  risk = risk_mat,
  pred_times = pred_times,
  time = test_surv_valid$survtime,
  event = test_surv_valid$event
)
print(sc)
plot(sc)
}
}

}
\seealso{
\code{\link{predict.INLAjoint}} for computing predictions.
}
